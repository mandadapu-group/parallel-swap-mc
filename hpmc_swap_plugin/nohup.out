5,6c5,6
< #ifndef _INTEGRATOR_HPMC_POLYDISPERSE_H_
< #define _INTEGRATOR_HPMC_POLYDISPERSE_H_
---
> #ifndef _INTEGRATOR_HPMC_MONO_SWAP_H_
> #define _INTEGRATOR_HPMC_MONO_SWAP_H_
8c8
< /*! \file IntegratorHPMCPolydisperse.h
---
> /*! \file IntegratorHPMCMonoSwap.h
19c19
< #include "ShapePolydisperse.h"
---
> #include "ShapePoint.h"
28,29c28,29
< #include "hoomd/Communicator.h"
< #include "hoomd/HOOMDMPI.h"
---
> #include <hoomd/Communicator.h>
> #include <hoomd/HOOMDMPI.h>
60c60,63
< 
---
>         std::vector<unsigned int> getOrderList()
>         {   
>             return m_update_order;
>         }
117c120
< class IntegratorHPMCPolydisperse : public IntegratorHPMCSwap
---
> class IntegratorHPMCMonoSwap : public IntegratorHPMCSwap
126c129
<         IntegratorHPMCPolydisperse(std::shared_ptr<SystemDefinition> sysdef,
---
>         IntegratorHPMCMonoSwap(std::shared_ptr<SystemDefinition> sysdef,
129c132
<         virtual ~IntegratorHPMCPolydisperse()
---
>         virtual ~IntegratorHPMCMonoSwap()
133,134c136,137
<             m_pdata->getBoxChangeSignal().template disconnect<IntegratorHPMCPolydisperse<Shape>, &IntegratorHPMCPolydisperse<Shape>::slotBoxChanged>(this);
<             m_pdata->getParticleSortSignal().template disconnect<IntegratorHPMCPolydisperse<Shape>, &IntegratorHPMCPolydisperse<Shape>::slotSorted>(this);
---
>             m_pdata->getBoxChangeSignal().template disconnect<IntegratorHPMCMonoSwap<Shape>, &IntegratorHPMCMonoSwap<Shape>::slotBoxChanged>(this);
>             m_pdata->getParticleSortSignal().template disconnect<IntegratorHPMCMonoSwap<Shape>, &IntegratorHPMCMonoSwap<Shape>::slotSorted>(this);
156d158
<         /* No support for external fields yet
157a160
>         /*
164d166
< 
209d210
<         /*
211c212
<             pybind11::list rij, pybind11::list qi, pybind11::list qj,
---
>             pybind11::list rij, pybind11::list qi, pybind11::list qj, unsigned int tag_i, unsigned int tag_j,
213c214,215
<         */
---
>         
>         //CHECK THIS MUHAMMAD
218c220
<             m_exec_conf->msg->notice(9) << "IntegratorHPMCPolydisperse: ghost layer width of " << ghost_width << std::endl;
---
>             m_exec_conf->msg->notice(9) << "IntegratorHPMCMonoSwap: ghost layer width of " << ghost_width << std::endl;
221a224
>         //CHECK THIS MUHAMMAD
228d230
<             flags[comm_flag::diameter] = 1;
232c234
<             o << "IntegratorHPMCPolydisperse: Requesting communication flags for pos tag ";
---
>             o << "IntegratorHPMCMonoSwap: Requesting communication flags for pos tag ";
241c243
<                 //flags[comm_flag::diameter] = 1;
---
>                 flags[comm_flag::diameter] = 1;
334a337
>         
343c346
< 
---
>         
381c384
< IntegratorHPMCPolydisperse<Shape>::IntegratorHPMCPolydisperse(std::shared_ptr<SystemDefinition> sysdef,
---
> IntegratorHPMCMonoSwap<Shape>::IntegratorHPMCMonoSwap(std::shared_ptr<SystemDefinition> sysdef,
390a394
>     //m_exec_conf->msg->notice(2) << "Constructing this Integrator! " << std::endl;
392c396
< 
---
>     
398,399c402,403
<     m_pdata->getBoxChangeSignal().template connect<IntegratorHPMCPolydisperse<Shape>, &IntegratorHPMCPolydisperse<Shape>::slotBoxChanged>(this);
<     m_pdata->getParticleSortSignal().template connect<IntegratorHPMCPolydisperse<Shape>, &IntegratorHPMCPolydisperse<Shape>::slotSorted>(this);
---
>     m_pdata->getBoxChangeSignal().template connect<IntegratorHPMCMonoSwap<Shape>, &IntegratorHPMCMonoSwap<Shape>::slotBoxChanged>(this);
>     m_pdata->getParticleSortSignal().template connect<IntegratorHPMCMonoSwap<Shape>, &IntegratorHPMCMonoSwap<Shape>::slotSorted>(this);
407a412
>     
412c417
< std::vector< std::string > IntegratorHPMCPolydisperse<Shape>::getProvidedLogQuantities()
---
> std::vector< std::string > IntegratorHPMCMonoSwap<Shape>::getProvidedLogQuantities()
416a422
>     // what is this?? (Muhammad)
427c433
< Scalar IntegratorHPMCPolydisperse<Shape>::getLogValue(const std::string& quantity, unsigned int timestep)
---
> Scalar IntegratorHPMCMonoSwap<Shape>::getLogValue(const std::string& quantity, unsigned int timestep)
461c467
< void IntegratorHPMCPolydisperse<Shape>::printStats()
---
> void IntegratorHPMCMonoSwap<Shape>::printStats()
481c487
< void IntegratorHPMCPolydisperse<Shape>::resetStats()
---
> void IntegratorHPMCMonoSwap<Shape>::resetStats()
487c493
< void IntegratorHPMCPolydisperse<Shape>::slotNumTypesChange()
---
> void IntegratorHPMCMonoSwap<Shape>::slotNumTypesChange()
511c517
< void IntegratorHPMCPolydisperse<Shape>::update(unsigned int timestep)
---
> void IntegratorHPMCMonoSwap<Shape>::update(unsigned int timestep)
513c519
<     m_exec_conf->msg->notice(10) << "HPMCPolydisperse update: " << timestep << std::endl;
---
>     m_exec_conf->msg->notice(10) << "HPMCMonoSwap update: " << timestep << std::endl;
530c536
<     
---
> 
536d541
<     //This is to choose which particles to swap
540d544
<     // compute the width of the active region
548c552
< 
---
>     
562a567
>     
565,566c570,571
< 
<     // loop over local particles nselect times
---
>     
>     // loop over local particles nselect times, where nselect is the number of trial moves we want to do per cell
572d576
<         ArrayHandle<Scalar> h_diameter(m_pdata->getDiameters(), access_location::host, access_mode::read);
574a579,582
>         ArrayHandle<unsigned int> h_tag(m_pdata->getTags(), access_location::host, access_mode::read); //give me tag of each particle i
>         ArrayHandle<unsigned int> h_rtag(m_pdata->getRTags(), access_location::host, access_mode::read); //give me tag of each particle i
>         ArrayHandle<Scalar> h_diameter(m_pdata->getDiameters(), access_location::host, access_mode::read);
>         
584c592
<             // read in the current position and orientation
---
>             // read in the current position and orientation for particle i
586a595
>             unsigned int tag_i = h_tag.data[i];
588c597,605
< 
---
>             int typ_i = __scalar_as_int(postype_i.w);
>             
>             //Store the old shape object and old positions
>             Shape shape_old(quat<Scalar>(orientation_i), m_params[typ_i]);
>             Scalar4 postype_old = postype_i;
>             vec3<Scalar> pos_old = pos_i; //<<-- will need for olf energy calculation
>             unsigned int tag_i_old = tag_i;
>             unsigned int i_old = i;
>             
598,602d614
<             /*// make a trial move for i
<             hoomd::RandomGenerator rng_i(hoomd::RNGIdentifier::HPMCMonoTrialMove, m_seed, i, m_exec_conf->getRank()*m_nselect + i_nselect, timestep);
<             unsigned int move_type_select = hoomd::UniformIntDistribution(0xffff)(rng_i);
<             bool move_type_translate = !shape_i.hasOrientation() || (move_type_select < m_move_ratio);
<             */
605,606d616
<             int typ_i = __scalar_as_int(postype_i.w);
<             Shape shape_i(quat<Scalar>(orientation_i), m_params[typ_i]);
610,613c620,667
< 
<             Shape shape_old(quat<Scalar>(orientation_i), m_params[typ_i]);
<             vec3<Scalar> pos_old = pos_i;
< 
---
>             
>             #ifdef ENABLE_DEBUG
>             m_exec_conf->msg->notice(5) << "My Random Number is: " << move_type_select  << std::endl;
>             m_exec_conf->msg->notice(5) << "I'm doing translational move: " << std::boolalpha << move_type_translate  << std::endl;
>             #endif
>             
>             //By default, we let the index of the second (potentially swapped) particle to be the same as particle i 
>             unsigned int swap_particle = cur_particle;
>             unsigned int i_swap = m_update_order[swap_particle];
> 
>             //Choose a second particle, if I'm doing swap moves. Or else. We use the default initialization which is the same as the first particle
>             if (!move_type_translate)
>                 {
>                     hoomd::UniformIntDistribution uniform(nactive-2);
>                     swap_particle = uniform(rng_i);
>                     if (swap_particle >= cur_particle)
>                     {   
>                         swap_particle += 1;
>                     }
>                     i_swap = m_update_order[swap_particle];
>                 }
>             
>             //Read in the current position and orientation for particle second particle, in case we start swapping
>             Scalar4 postype_swap = h_postype.data[i_swap];
>             #ifdef ENABLE_MPI
>             if (m_comm)
>             {
>                 // only move particle if active
>                 if (!isActive(make_scalar3(postype_swap.x, postype_swap.y, postype_swap.z), box, ghost_fraction))
>                     continue;
>             }
>             #endif
>             
>             //whether I continue to swap or not, I should store its orientation, tag, position, and type
>             Scalar4 orientation_swap = h_orientation.data[i_swap];
>             unsigned int tag_swap = h_tag.data[i_swap];
>             vec3<Scalar> pos_swap = vec3<Scalar>(postype_swap);
>             int typ_swap = __scalar_as_int(postype_swap.w);
>             
>             //Store the old shape object and old positions of the second particle
>             Scalar4 orientation_swap_old = h_orientation.data[i_swap];
>             Scalar4 postype_swap_old = h_postype.data[i_swap];
>             vec3<Scalar> pos_swap_old = pos_swap;
>             unsigned int tag_swap_old = tag_swap;
>             unsigned int i_swap_old = i_swap;
>             Shape shape_swap_old(quat<Scalar>(orientation_swap_old), m_params[typ_swap]);
>             OverlapReal diameter_swap_old = shape_swap_old.getCircumsphereDiameter(tag_swap_old); 
>             //Attempt the move!
619c673
<                     if (!shape_i.ignoreStatistics())
---
>                     if (!shape_old.ignoreStatistics())
633a688
>                 
636,637c691,694
<                 {/*
<                 if (h_a.data[typ_i] == 0.0)
---
>                 {
>                 // According to Ludovic's paper, you should also add an extra rejection criterion
>                 //If the difference in diameter is not smaller than my dr_reject (meaning that it is actually bigger) then I immediately reject the particles
>                 if (fabs(shape_old.getCircumsphereDiameter(tag_i)-shape_swap_old.getCircumsphereDiameter(tag_swap)) > m_dr_reject) 
639,640c696,706
<                     if (!shape_i.ignoreStatistics())
<                         counters.rotate_accept_count++;
---
>                     if (!shape_old.ignoreStatistics() || !shape_swap_old.ignoreStatistics())
>                         counters.swap_reject_count++;
>                     continue;
>                     }
>                 
>                 //If, somehow, I picked the same particle (it shouldn't) let's just skip it
>                 //It's here for consistency, if somehow someone messes around with my code have particle i as the possible choice to swap particles with
>                 if (postype_swap_old == postype_i)
>                     {
>                     if (!shape_old.ignoreStatistics() || !shape_swap_old.ignoreStatistics())
>                         counters.swap_accept_count++;
644c710,744
<                 move_rotate(shape_i.orientation, rng_i, h_a.data[typ_i], ndim);*/
---
>                 #ifdef ENABLE_MPI
>                 if (m_comm)
>                     {
>                     // check if either chosen particle is part of the active region or not
>                     if (!isActive(vec_to_scalar3(pos_i), box, ghost_fraction) || !isActive(vec_to_scalar3(pos_swap), box, ghost_fraction))
>                          continue;
>                     }
>                 #endif
>                 
>                 /*
>                 if (m_swap_mode)
>                     {
>                     //start swapping the tags and radii
>                     //shape_i.changeRadius(shape_swap_old.getCircumsphereDiameter(tag_swap_old),tag_swap_old)
>                     //shape_swap.changeRadius(shape_i.getCircumsphereDiameter(tag_swap_old),tag_swap_old)
>                     tag_swap = tag_i;
>                     tag_i = tag_swap_old;
>                     i_swap = i;
>                     i = i_swap_old;
>                     }
>                 else*/
>                 if (!m_swap_mode)
>                     {
>                     //Let's start by swapping postype
>                     postype_swap = postype_i;
>                     postype_i = postype_swap_old; 
>                     //update the pos variables
>                     pos_i = vec3<Scalar>(postype_i); //I already swapped postype
>                     pos_swap = vec3<Scalar>(postype_swap); //I already swapped postype
>                    
>                     //update the orientation
>                     //orientation_swap_old = h_orientation.data[i_swap];
>                     }
>                 orientation_swap = orientation_i; 
>                 orientation_i = orientation_swap_old;
646,647c746,757
<               
< 
---
>             Shape shape_i(quat<Scalar>(orientation_i), m_params[typ_i]);
>             Shape shape_swap(quat<Scalar>(orientation_swap), m_params[typ_swap]);
>             OverlapReal diameter_i = shape_i.getCircumsphereDiameter(tag_i);
>             OverlapReal diameter_swap = shape_swap.getCircumsphereDiameter(tag_swap);
>             if (!move_type_translate && m_swap_mode)
>             {
>                 shape_i.changeRadius(0.5*diameter_swap_old,tag_i);
>                 shape_swap.changeRadius(0.5*diameter_i,tag_swap);
>                 diameter_i = shape_i.getCircumsphereDiameter(tag_i);
>                 diameter_swap = shape_swap.getCircumsphereDiameter(tag_swap);
>             }
>             
649c759,760
<             OverlapReal diameter_i = h_diameter.data[i];
---
>             // In the previous code it's basically rcut. Nothing else.
>             // They're needed at this stage because we need 
650a762
>             OverlapReal r_cut_patch_i_swapj = 0;
654a767
>                 r_cut_patch_i_swapj = m_patch->getScaledRCut()*0.5*diameter_swap;
656c769
< 
---
>             
658c771
<             OverlapReal R_query = std::max(diameter_i,//OverlapReal(2.0),
---
>             OverlapReal R_query = std::max(diameter_i/OverlapReal(2.0),
661c774,779
< 
---
>             
>             // subtract minimum AABB extent from search radius
>             R_query = std::max(diameter_swap/OverlapReal(2.0),
>                 r_cut_patch_i_swapj-getMinCoreDiameter()/(OverlapReal)2.0);
>             detail::AABB aabb_swap_local = detail::AABB(vec3<Scalar>(0,0,0),R_query);
>             
670,677c788,799
<                 vec3<Scalar> pos_i_image = pos_i + m_image_list[cur_image];
<                 detail::AABB aabb = aabb_i_local;
<                 aabb.translate(pos_i_image);
< 
<                 // stackless search
<                 for (unsigned int cur_node_idx = 0; cur_node_idx < m_aabb_tree.getNumNodes(); cur_node_idx++)
<                     {
<                     if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
---
>                     vec3<Scalar> pos_i_image = pos_i + m_image_list[cur_image];
>                     detail::AABB aabb = aabb_i_local;
>                     aabb.translate(pos_i_image);
>                     
>                     //I'll have to construct yet another aabb tree for the second particle (swappos)!
>                     vec3<Scalar> pos_swap_image = pos_swap + m_image_list[cur_image];
>                     detail::AABB aabbswap = aabb_swap_local;
>                     aabbswap.translate(pos_swap_image);
>                     // stackless search
>                     for (unsigned int cur_node_idx = 0; cur_node_idx < m_aabb_tree.getNumNodes(); cur_node_idx++)
>                     { 
>                         if (move_type_translate)
679,681c801
<                         if (m_aabb_tree.isNodeLeaf(cur_node_idx))
<                             {
<                             for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
---
>                             if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
683,690c803
<                                 // read in its position and orientation
<                                 unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
< 
<                                 Scalar4 postype_j;
<                                 Scalar4 orientation_j;
< 
<                                 // handle j==i situations
<                                 if ( j != i )
---
>                                 if (m_aabb_tree.isNodeLeaf(cur_node_idx))
692,694c805,870
<                                     // load the position and orientation of the j particle
<                                     postype_j = h_postype.data[j];
<                                     orientation_j = h_orientation.data[j];
---
>                                     for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
>                                         {
>                                         // read in its position and orientation
>                                         unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
>                                         unsigned int tag_j = h_tag.data[j];
> 
>                                         Scalar4 postype_j;
>                                         Scalar4 orientation_j;
>                                         if ( j != i ) 
>                                             {
>                                             // load the position and orientation of the j particle
>                                             postype_j = h_postype.data[j];
>                                             orientation_j = h_orientation.data[j];
>                                             }
>                                         else
>                                             {
>                                             if (cur_image == 0)
>                                                 {
>                                                 // in the first image, skip i == j
>                                                 continue;
>                                                 }
>                                             else
>                                                 {
>                                                 // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                 postype_j = make_scalar4(pos_i.x, pos_i.y, pos_i.z, postype_i.w);
>                                                 orientation_j = quat_to_scalar4(shape_i.orientation);
>                                                 }
>                                             }
>                                         
>                                         // put particles in coordinate system of particle i
>                                         vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
> 
>                                         unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                         Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
>                                         OverlapReal diameter_j = shape_j.getCircumsphereDiameter(tag_j);
>                                         Scalar rcut = 0;
>                                         if (m_patch)
>                                             rcut = r_cut_patch_ij+m_patch->getScaledRCut()*0.5*diameter_j;
> 
>                                         counters.overlap_checks++;
>                                         if (!m_soft_mode && h_overlaps.data[m_overlap_idx(typ_i, typ_j)]
>                                             && check_circumsphere_overlap_plugin(r_ij, shape_i, shape_j)
>                                             && test_overlap_plugin(r_ij, shape_i, shape_j, tag_i, tag_j, counters.overlap_err_count))
>                                             {
>                                             overlap = true;
>                                             break;
>                                             }
>                                         //Let me see if I wanna do something with this.
>                                         // I'm not sure yet how I want to organize interacting hard/soft particles. For now, I only consider attractive interactions
>                                         // Only when the particles are soft
>                                         if (m_soft_mode && m_patch && !m_patch_log && dot(r_ij,r_ij) <= rcut*rcut) // If there is no overlap and m_patch is not NULL, calculate energy
>                                             {
>                                             // deltaU = U_old - U_new: subtract energy of new configuration
>                                             patch_field_energy_diff -= m_patch->energy(r_ij, typ_i,
>                                                                        quat<float>(orientation_i),
>                                                                        //h_diameter.data[i],
>                                                                        diameter_i,
>                                                                        h_charge.data[i],
>                                                                        typ_j,
>                                                                        quat<float>(orientation_j),
>                                                                        //h_diameter.data[j],
>                                                                        diameter_j,
>                                                                        h_charge.data[j]
>                                                                        );
>                                             }
>                                         }
696c872,883
<                                 else
---
>                                 }
>                             else
>                                 {
>                                 // skip ahead
>                                 cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
>                                 }
>                         } //end of if I do translation move 
>                         else
>                         {
>                             if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb) || detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabbswap))
>                                 {
>                                 if (m_aabb_tree.isNodeLeaf(cur_node_idx))
698c885
<                                     if (cur_image == 0)
---
>                                     for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
700,703c887,989
<                                         // in the first image, skip i == j
<                                         continue;
<                                         }
<                                     else
---
>                                         // read in its position and orientation
>                                         unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
>                                         //unsigned int tag_j = m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
>                                         unsigned int tag_j = h_tag.data[j];//m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
> 
>                                         Scalar4 postype_j;
>                                         Scalar4 orientation_j;
>                                         Scalar4 postype_j_swap;
>                                         Scalar4 orientation_j_swap;
>                                         
>                                         //bool j_issamewith_i = false;
>                                         //bool j_issamewith_i_swap = false;
>                                         if ( j != i  && j != i_swap) 
>                                             {
>                                             // load the position and orientation of the j particle
>                                             postype_j = h_postype.data[j];
>                                             postype_j_swap = h_postype.data[j];
>                                             orientation_j = h_orientation.data[j];
>                                             orientation_j_swap = h_orientation.data[j];
>                                             }
>                                         else if ( j != i  && j == i_swap)
>                                             {
>                                                 postype_j = h_postype.data[j];
>                                                 orientation_j = h_orientation.data[j];
>                                                 if (cur_image == 0 && !m_soft_mode)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     //j_issamewith_i_swap = true;
>                                                     //If j is the same i, we continue. We wouldn't swap particles that overlap in the first place!
>                                                     // but we have to take into account their interactions, if required
>                                                     //if (!m_soft_mode)
>                                                         continue;
>                                                     //else
>                                                     //{
>                                                     //}
>                                                         //j_issamewith_i_swap = true;
>                                                     //else
>                                                     //    continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                     postype_j_swap = make_scalar4(pos_swap.x, pos_swap.y, pos_swap.z, postype_swap.w);
>                                                     orientation_j_swap = quat_to_scalar4(shape_swap.orientation);
>                                                     }
>                                             } 
>                                         else if ( j == i  && j != i_swap)
>                                             {
>                                                 postype_j_swap = h_postype.data[j];
>                                                 orientation_j_swap = h_orientation.data[j];
>                                                 if (cur_image == 0 && !m_soft_mode)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     // But we can't skip j with i_swap overlap check
>                                                     //j_issamewith_i = true;
>                                                     //If j is the same i_swap, we continue. We wouldn't swap particles that overlap in the first place!
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                     postype_j = make_scalar4(pos_i.x, pos_i.y, pos_i.z, postype_i.w);
>                                                     orientation_j = quat_to_scalar4(shape_i.orientation);
>                                                     }
>                                             } 
>                                         else if ( j == i  && j == i_swap)
>                                             {
>                                                 if (cur_image == 0 && !m_soft_mode)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                         postype_j_swap = make_scalar4(pos_swap.x, pos_swap.y, pos_swap.z, postype_swap.w);
>                                                         orientation_j_swap = quat_to_scalar4(shape_swap.orientation);
>                                                         postype_j = make_scalar4(pos_i.x, pos_i.y, pos_i.z, postype_i.w);
>                                                         orientation_j = quat_to_scalar4(shape_i.orientation);
>                                                     }
>                                             } 
>                                         
>                                         // put particles in coordinate system of particle i
>                                         vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
>                                         vec3<Scalar> r_ij_swap = vec3<Scalar>(postype_j_swap) - pos_swap_image;
> 
>                                         unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                         Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
>                                         Scalar diameter_j = shape_j.getCircumsphereDiameter(tag_j); 
>                                         //m_exec_conf->msg->notice(5) << "Is the error here (2) ? "  << std::endl;
>                                         //m_exec_conf->msg->notice(5) << "i_swap = "  << i_swap << std::endl;
>                                         //m_exec_conf->msg->notice(5) << "i = "  << i << std::endl;
>                                         //m_exec_conf->msg->notice(5) << "j = "  << j << std::endl;
>                                         //I GET IT!!!
>                                         unsigned int typ_j_swap = __scalar_as_int(postype_j_swap.w);
>                                         Shape shape_j_swap(quat<Scalar>(orientation_j_swap), m_params[typ_j_swap]);
>                                         Scalar diameter_j_swap = shape_j_swap.getCircumsphereDiameter(tag_j); 
>                                         //unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                         //Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
> 
>                                         OverlapReal rcut = 0.0;
>                                         OverlapReal rcut_swap = 0.0;
>                                         if (m_patch)
705,707c991,992
<                                         // If this is particle i and we are in an outside image, use the translated position and orientation
<                                         postype_j = make_scalar4(pos_i.x, pos_i.y, pos_i.z, postype_i.w);
<                                         orientation_j = quat_to_scalar4(shape_i.orientation);
---
>                                             rcut = r_cut_patch_ij+0.5*m_patch->getScaledRCut()*diameter_j;
>                                             rcut_swap = r_cut_patch_i_swapj+0.5*m_patch->getScaledRCut()*diameter_j_swap;
709,712d993
<                                     }
< 
<                                 // put particles in coordinate system of particle i
<                                 vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
714,741c995,1076
<                                 unsigned int typ_j = __scalar_as_int(postype_j.w);
<                                 Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
<                                 OverlapReal diameter_j = h_diameter.data[j];
<                                 Scalar rcut = 0.0;
<                                 if (m_patch)
<                                     //rcut = r_cut_patch + 0.5 * m_patch->getAdditiveCutoff(typ_j);
<                                     rcut = r_cut_patch_ij+m_patch->getScaledRCut()*0.5*diameter_j;
< 
<                                 counters.overlap_checks++;
<                                 if (!m_soft_mode && h_overlaps.data[m_overlap_idx(typ_i, typ_j)]
<                                         && check_circumsphere_overlap_plugin(r_ij, diameter_i, diameter_j)
<                                         && test_overlap_plugin(r_ij, diameter_i, diameter_j, counters.overlap_err_count))
<                                     {
<                                     overlap = true;
<                                     break;
<                                     }
<                                 else if (m_soft_mode && m_patch && !m_patch_log && dot(r_ij,r_ij) <= rcut*rcut) // If there is no overlap and m_patch is not NULL, calculate energy
<                                     {
<                                     // deltaU = U_old - U_new: subtract energy of new configuration
<                                     patch_field_energy_diff -= m_patch->energy(r_ij, typ_i,
<                                                                quat<float>(shape_i.orientation),
<                                                                h_diameter.data[i],
<                                                                h_charge.data[i],
<                                                                typ_j,
<                                                                quat<float>(orientation_j),
<                                                                h_diameter.data[j],
<                                                                h_charge.data[j]
<                                                                );
---
>                                         counters.overlap_checks++;
>                                         if (!m_soft_mode && (h_overlaps.data[m_overlap_idx(typ_i, typ_j)]
>                                             || h_overlaps.data[m_overlap_idx(typ_swap, typ_j_swap)])
>                                             && (check_circumsphere_overlap_plugin(r_ij, shape_i, shape_j)
>                                             || check_circumsphere_overlap_plugin(r_ij_swap, shape_swap, shape_j_swap))
>                                             && (test_overlap_plugin(r_ij, shape_i, shape_j, tag_i, tag_j, counters.overlap_err_count)
>                                             || test_overlap_plugin(r_ij_swap, shape_swap, shape_j_swap, tag_swap, tag_j, counters.overlap_err_count)))
>                                             {
>                                                 overlap = true;
>                                                 break;
>                                             }
>                                         
>                                         // If there is no overlap and m_patch is not NULL, calculate energy
>                                         // I'm not sure yet how I want to organize interacting hard/soft particles. For now, I only consider attractive interactions
>                                         // Only when the particles are soft
>                                         if (m_soft_mode && m_patch && !m_patch_log && (dot(r_ij,r_ij) <= rcut*rcut || dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap) ) 
>                                             {
>                                                 //So I gotta check if particle j is inside the rcut domain of i or i_swap
>                                                 // So, you could have particle j in either i or i swap . . . .
>                                                 if (dot(r_ij,r_ij) != 0 &&  dot(r_ij,r_ij) <= rcut*rcut &&  dot(r_ij_swap,r_ij_swap) > rcut_swap*rcut_swap)
>                                                 { 
>                                                     // deltaU = U_old - U_new: subtract energy of new configuration
>                                                     patch_field_energy_diff -= m_patch->energy(r_ij, typ_i,
>                                                                                quat<float>(orientation_i),
>                                                                                //h_diameter.data[i],
>                                                                                //shape_i.getCircumsphereDiameter(tag_i),
>                                                                                diameter_i,
>                                                                                h_charge.data[i],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                //shape_j.getCircumsphereDiameter(tag_j),
>                                                                                diameter_j, 
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                                 else if ( dot(r_ij_swap,r_ij_swap) != 0 && dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap && dot(r_ij,r_ij) > rcut*rcut)
>                                                 {
>                                                     patch_field_energy_diff -= m_patch->energy(r_ij_swap, typ_swap,
>                                                                                quat<float>(shape_swap.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                //shape_swap.getCircumsphereDiameter(tag_swap),
>                                                                                diameter_swap,
>                                                                                h_charge.data[i_swap],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                //shape_j_swap.getCircumsphereDiameter(tag_j),
>                                                                                diameter_j_swap,
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                                 else if ( dot(r_ij,r_ij) != 0 && dot(r_ij_swap,r_ij_swap) != 0 && dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap &&  dot(r_ij,r_ij) <= rcut*rcut)
>                                                 {
>                                                     patch_field_energy_diff -= m_patch->energy(r_ij, typ_i,
>                                                                                quat<float>(shape_i.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                diameter_i,
>                                                                                h_charge.data[i],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                diameter_j,
>                                                                                h_charge.data[j]
>                                                                                );
>                                                     patch_field_energy_diff -= m_patch->energy(r_ij_swap, typ_swap,
>                                                                                quat<float>(shape_swap.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                //shape_swap.getCircumsphereDiameter(tag_swap),
>                                                                                diameter_swap,
>                                                                                h_charge.data[i_swap],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                //shape_j_swap.getCircumsphereDiameter(tag_j),
>                                                                                diameter_j_swap,
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                             //then substract, yet again for the swap particle!
>                                             }//end of energy evaluation
>                                         }
744,751c1079,1087
<                             }
<                         }
<                     else
<                         {
<                         // skip ahead
<                         cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
<                         }
< 
---
>                             else
>                                 {
>                                 // skip ahead
>                                 cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
>                                 }
>                         } 
>                         if (overlap)
>                             break;
>                     } // end loop over AABB nodes
754,757d1089
<                     }  // end loop over AABB nodes
< 
<                 if (overlap)
<                     break;
761c1093,1094
<             if (m_patch && !m_patch_log && !overlap)
---
>             // these calculations must also be adjusted (for instance if they are doing swap moves or not)
>             if (m_soft_mode && m_patch && !m_patch_log && !overlap)
768a1102,1105
>                     //I'll have to construct yet another aabb tree for the second particle (swappos)!
>                     vec3<Scalar> pos_swap_image = pos_swap_old + m_image_list[cur_image];
>                     detail::AABB aabbswap = aabb_swap_local;
>                     aabbswap.translate(pos_swap_image);
772c1109
<                         if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
---
>                             if (move_type_translate)
774,776c1111
<                             if (m_aabb_tree.isNodeLeaf(cur_node_idx))
<                                 {
<                                 for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
---
>                                 if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
778,785c1113
<                                     // read in its position and orientation
<                                     unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
< 
<                                     Scalar4 postype_j;
<                                     Scalar4 orientation_j;
< 
<                                     // handle j==i situations
<                                     if ( j != i )
---
>                                     if (m_aabb_tree.isNodeLeaf(cur_node_idx))
787,789c1115,1172
<                                         // load the position and orientation of the j particle
<                                         postype_j = h_postype.data[j];
<                                         orientation_j = h_orientation.data[j];
---
>                                         for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
>                                             {
>                                             // read in its position and orientation
>                                             unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
>                                             unsigned int tag_j = h_tag.data[j];//m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
> 
>                                             Scalar4 postype_j;
>                                             Scalar4 orientation_j;
>                                             //Scalar diameter_j = shape_j.getCircumsphereDiameter(tag_j);
>                                             // handle j==i situations
>                                             if ( j != i )
>                                                 {
>                                                 // load the position and orientation of the j particle
>                                                 postype_j = h_postype.data[j];
>                                                 orientation_j = h_orientation.data[j];
>                                                 //diameter_j = h_diameter.data[j];
>                                                 }
>                                             else
>                                                 {
>                                                 if (cur_image == 0)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                     postype_j = make_scalar4(pos_old.x, pos_old.y, pos_old.z, postype_i.w);
>                                                     orientation_j = quat_to_scalar4(shape_old.orientation);
>                                                     //diameter_j = h_diameter.data[i];
>                                                     }
>                                                 }
> 
>                                             // put particles in coordinate system of particle i
>                                             vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
>                                             unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                             Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
>                                             OverlapReal diameter_j = shape_j.getCircumsphereDiameter(tag_j);
> 
>                                             Scalar rcut = r_cut_patch_ij + 0.5 * m_patch->getScaledRCut()*diameter_j;
> 
>                                             // deltaU = U_old - U_new: add energy of old configuration
>                                             // Additional check to see if I have soft particles
>                                             if (m_soft_mode && dot(r_ij,r_ij) <= rcut*rcut)
>                                                 patch_field_energy_diff += m_patch->energy(r_ij,
>                                                                            typ_i,
>                                                                            quat<float>(orientation_i),
>                                                                            //h_diameter.data[i],
>                                                                            //shape_i.getCircumsphereDiameter(tag_i),
>                                                                            diameter_i,
>                                                                            h_charge.data[i],
>                                                                            typ_j,
>                                                                            quat<float>(orientation_j),
>                                                                            //h_diameter.data[j],
>                                                                            diameter_j,
>                                                                            //shape_j.getCircumsphereDiameter(tag_j),
>                                                                            h_charge.data[j]);
>                                             }
791c1174,1187
<                                     else
---
>                                     }
>                                 else
>                                     {
>                                     // skip ahead
>                                     cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
>                                     }
>                             }
>                             else
>                             {
>                             if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb) || detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabbswap))
>                                 {
>                                 if (m_aabb_tree.isNodeLeaf(cur_node_idx))
>                                     {
>                                     for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
793c1189,1199
<                                         if (cur_image == 0)
---
>                                         // read in its position and orientation
>                                         unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
>                                         //unsigned int tag_j = m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
>                                         unsigned int tag_j = h_tag.data[j];//m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
> 
>                                         Scalar4 postype_j;
>                                         Scalar4 orientation_j;
>                                         Scalar4 postype_j_swap;
>                                         Scalar4 orientation_j_swap;
> 
>                                         if ( j != i  && j != i_swap) 
795,796c1201,1205
<                                             // in the first image, skip i == j
<                                             continue;
---
>                                             // load the position and orientation of the j particle
>                                             postype_j = h_postype.data[j];
>                                             postype_j_swap = h_postype.data[j];
>                                             orientation_j = h_orientation.data[j];
>                                             orientation_j_swap = h_orientation.data[j];
798c1207
<                                         else
---
>                                         else if ( j != i  && j == i_swap)
800,804c1209,1269
<                                             // If this is particle i and we are in an outside image, use the translated position and orientation
<                                             postype_j = make_scalar4(pos_old.x, pos_old.y, pos_old.z, postype_i.w);
<                                             orientation_j = quat_to_scalar4(shape_old.orientation);
<                                             }
<                                         }
---
>                                                 postype_j = h_postype.data[j];
>                                                 orientation_j = h_orientation.data[j];
>                                                 if (cur_image == 0)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                     postype_j_swap = make_scalar4(pos_swap_old.x, pos_swap_old.y, pos_swap_old.z, postype_swap.w);
>                                                     orientation_j_swap = quat_to_scalar4(shape_swap_old.orientation);
>                                                     }
>                                             } 
>                                         else if ( j == i  && j != i_swap)
>                                             {
>                                                 postype_j_swap = h_postype.data[j];
>                                                 orientation_j_swap = h_orientation.data[j];
>                                                 if (cur_image == 0)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                     postype_j = make_scalar4(pos_old.x, pos_old.y, pos_old.z, postype_i.w);
>                                                     orientation_j = quat_to_scalar4(shape_old.orientation);
>                                                     }
>                                             } 
>                                         else if ( j == i  && j == i_swap)
>                                             {
>                                                 if (cur_image == 0)
>                                                     {
>                                                     // in the first image, skip i == j
>                                                     continue;
>                                                     }
>                                                 else
>                                                     {
>                                                     // If this is particle i and we are in an outside image, use the translated position and orientation
>                                                         postype_j_swap = make_scalar4(pos_swap_old.x, pos_swap_old.y, pos_swap_old.z, postype_swap.w);
>                                                         orientation_j_swap = quat_to_scalar4(shape_swap_old.orientation);
>                                                         postype_j = make_scalar4(pos_old.x, pos_old.y, pos_old.z, postype_old.w);
>                                                         orientation_j = quat_to_scalar4(shape_old.orientation);
>                                                     }
>                                             } 
>                                         
>                                         // put particles in coordinate system of particle i
>                                         vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
>                                         vec3<Scalar> r_ij_swap = vec3<Scalar>(postype_j_swap) - pos_swap_image;
> 
>                                         unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                         Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
>                                         Scalar diameter_j = shape_j.getCircumsphereDiameter(tag_j);
>                                         unsigned int typ_j_swap = __scalar_as_int(postype_j_swap.w);
>                                         Shape shape_j_swap(quat<Scalar>(orientation_j_swap), m_params[typ_j_swap]);
>                                         Scalar diameter_j_swap = shape_j_swap.getCircumsphereDiameter(tag_j);
>                                         //unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                         //Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
>                                         Scalar rcut = r_cut_patch_ij + 0.5 * m_patch->getScaledRCut()*diameter_j;
>                                         Scalar rcut_swap = r_cut_patch_i_swapj + 0.5 * m_patch->getScaledRCut()*diameter_j_swap;
806,824c1271,1331
<                                     // put particles in coordinate system of particle i
<                                     vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
<                                     unsigned int typ_j = __scalar_as_int(postype_j.w);
<                                     Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
<                                     OverlapReal diameter_j = h_diameter.data[j];
<                                     //Scalar rcut = r_cut_patch + 0.5 * m_patch->getAdditiveCutoff(typ_j);
<                                     Scalar rcut = r_cut_patch_ij + 0.5 * m_patch->getScaledRCut()*diameter_j;
< 
<                                     // deltaU = U_old - U_new: add energy of old configuration
<                                     if (dot(r_ij,r_ij) <= rcut*rcut)
<                                         patch_field_energy_diff += m_patch->energy(r_ij,
<                                                                    typ_i,
<                                                                    quat<float>(orientation_i),
<                                                                    h_diameter.data[i],
<                                                                    h_charge.data[i],
<                                                                    typ_j,
<                                                                    quat<float>(orientation_j),
<                                                                    h_diameter.data[j],
<                                                                    h_charge.data[j]);
---
>                                         if (m_soft_mode && (dot(r_ij,r_ij) <= rcut*rcut || dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap) ) 
>                                             {
>                                                 //So I gotta check if particle j is inside the rcut domain of i or i_swap
>                                                 // So, you could have particle j in either i or i swap . . . .
>                                                 if ( dot(r_ij,r_ij) <= rcut*rcut &&  dot(r_ij_swap,r_ij_swap) > rcut_swap*rcut_swap)
>                                                 { 
>                                                     // deltaU = U_old - U_new: subtract energy of new configuration
>                                                     patch_field_energy_diff += m_patch->energy(r_ij, typ_i,
>                                                                                quat<float>(shape_old.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                shape_old.getCircumsphereDiameter(tag_i_old),
>                                                                                h_charge.data[i],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                shape_j.getCircumsphereDiameter(tag_j),
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                                 else if ( dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap &&  dot(r_ij,r_ij) > rcut*rcut)
>                                                 {
>                                                     patch_field_energy_diff += m_patch->energy(r_ij_swap, typ_swap,
>                                                                                quat<float>(shape_swap_old.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                shape_swap_old.getCircumsphereDiameter(tag_swap_old),
>                                                                                h_charge.data[i_swap],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                shape_j_swap.getCircumsphereDiameter(tag_j),
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                                 else if ( dot(r_ij_swap,r_ij_swap) <= rcut_swap*rcut_swap &&  dot(r_ij,r_ij) <= rcut*rcut)
>                                                 {
>                                                     // deltaU = U_old - U_new: subtract energy of new configuration
>                                                     patch_field_energy_diff += m_patch->energy(r_ij, typ_i,
>                                                                                quat<float>(orientation_i),
>                                                                                //h_diameter.data[i],
>                                                                                shape_old.getCircumsphereDiameter(tag_i_old),
>                                                                                h_charge.data[i],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                shape_j_swap.getCircumsphereDiameter(tag_j),
>                                                                                h_charge.data[j]
>                                                                                );
>                                                     patch_field_energy_diff += m_patch->energy(r_ij_swap, typ_swap,
>                                                                                quat<float>(shape_swap_old.orientation),
>                                                                                //h_diameter.data[i],
>                                                                                shape_swap_old.getCircumsphereDiameter(tag_swap_old),
>                                                                                h_charge.data[i_swap],
>                                                                                typ_j,
>                                                                                quat<float>(orientation_j),
>                                                                                //h_diameter.data[j],
>                                                                                shape_j_swap.getCircumsphereDiameter(tag_j),
>                                                                                h_charge.data[j]
>                                                                                );
>                                                 }
>                                             }//end of energy evaluation
>                                         }
827,832c1334,1339
<                             }
<                         else
<                             {
<                             // skip ahead
<                             cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
<                             }
---
>                             else
>                                 {
>                                 // skip ahead
>                                 cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
>                                 }
>                             }// of swap move stuff
848,849c1355
<                 // increment accept counter and assign new position
<                 if (!shape_i.ignoreStatistics())
---
>                 if (move_type_translate)
851,855c1357,1361
<                     if (move_type_translate)
<                         counters.translate_accept_count++;
<                     else
<                         counters.rotate_accept_count++;
<                     }
---
>                     // increment accept counter and assign new position
>                     if (!shape_i.ignoreStatistics())
>                         {
>                             counters.translate_accept_count++;
>                         }
857,860c1363,1366
<                 // update the position of the particle in the tree for future updates
<                 detail::AABB aabb = aabb_i_local;
<                 aabb.translate(pos_i);
<                 m_aabb_tree.update(i, aabb);
---
>                     // update the position of the particle in the tree for future updates
>                     detail::AABB aabb = aabb_i_local;
>                     aabb.translate(pos_i);
>                     m_aabb_tree.update(i, aabb);
862,863c1368,1369
<                 // update position of particle
<                 h_postype.data[i] = make_scalar4(pos_i.x,pos_i.y,pos_i.z,postype_i.w);
---
>                     // update position of particle
>                     h_postype.data[i] = make_scalar4(pos_i.x,pos_i.y,pos_i.z,postype_i.w);
865c1371,1376
<                 if (shape_i.hasOrientation())
---
>                     if (shape_i.hasOrientation())
>                         {
>                         h_orientation.data[i] = quat_to_scalar4(shape_i.orientation);
>                         }
>                     }
>                 else
867c1378,1435
<                     h_orientation.data[i] = quat_to_scalar4(shape_i.orientation);
---
>                         // increment accept counter and assign new position
>                         if (!shape_i.ignoreStatistics() && !shape_swap.ignoreStatistics())
>                             {
>                                 counters.swap_accept_count++;
>                             }
>                     
> 
>                     
>                         if (m_swap_mode)
>                             {
>                             /*#ifdef ENABLE_MPI
>                             if (m_comm)
>                             {
>                                 m_exec_conf->msg->error() << "Attempting to do swap_mode='diameter' in parallel simulation" << std::endl;
>                                 throw std::runtime_error("swap_mode='diameter' is not supported in parallel simulation (yet)");
>                             }
>                             #endif*/
>                             //These will have the new radii because the tags are swapped  
>                             OverlapReal radius_swap= shape_swap.getCircumsphereDiameter(tag_swap)/OverlapReal(2.0); //<-- tag_swap = tag_i
> 
>                             OverlapReal radius_i = shape_i.getCircumsphereDiameter(tag_i)/OverlapReal(2.0);  //<-- tag_i = tag_swap_old
>                             
>                             //Use the old tags for the radii to update
>                             //m_exec_conf->msg->notice(2) << "Initially has radius" << 2*m_params[typ_swap].radii[tag_swap_old] << std::endl;//timestep << std::endl;
>                             
>                             m_params[typ_swap].changeRadius(radius_swap,tag_swap);//radii[tag_swap_old] = radius_swap; //<-- tag_i
>                             m_params[typ_swap].changeRadius(radius_swap,tag_swap);//radii[tag_swap_old] = radius_swap; //<-- tag_i
>                             
>                             //m_exec_conf->msg->notice(2) << "Now has radius" << 2*m_params[typ_swap].radii[tag_swap_old] << std::endl;//timestep << std::endl;
>                             m_params[typ_i].changeRadius(radius_i,tag_i);//radii[tag_i_old] = radius_i; //<-- tag_i  = tag_swap_old
> 
>                             //Don't forget to reflect those changes to the actual particle data
>                             //m_exec_conf->msg->notice(2) << "Next,Initially has radius" << h_diameter.data[i_swap_old] << std::endl;//timestep << std::endl;
>                             h_diameter.data[i_swap] = 2*radius_swap;
>                             //m_exec_conf->msg->notice(2) << "Now has radius" << h_diameter.data[i_swap_old] << std::endl;//timestep << std::endl;
>                             h_diameter.data[i] = 2*radius_i;
>                             }
>                         else
>                             {
>                             // update the position of the particle in the tree for future updates
>                             detail::AABB aabb = aabb_i_local;
>                             aabb.translate(pos_i);
>                             m_aabb_tree.update(i, aabb);
>                             
>                             // update the position of the particle in the tree for future updates
>                             detail::AABB aabbswap = aabb_swap_local;
>                             aabbswap.translate(pos_swap);
>                             m_aabb_tree.update(i_swap, aabbswap);
> 
>                             // update position of particle
>                             h_postype.data[i] = make_scalar4(pos_i.x,pos_i.y,pos_i.z,postype_i.w);
>                             h_postype.data[i_swap] = make_scalar4(pos_swap.x,pos_swap.y,pos_swap.z,postype_swap.w);
>                             }
>                         if (shape_i.hasOrientation() && shape_swap.hasOrientation())
>                             {
>                             h_orientation.data[i] = quat_to_scalar4(shape_i.orientation);
>                             h_orientation.data[i_swap] = quat_to_scalar4(shape_swap.orientation);
>                             }
872c1440
<                 if (!shape_i.ignoreStatistics())
---
>                 if (!shape_i.ignoreStatistics())// && !shape_swap.ignoreStatistics())
877,878c1445,1446
<                     else
<                         counters.rotate_reject_count++;
---
>                     else if (!shape_swap.ignoreStatistics())
>                         counters.swap_reject_count++;
938c1506
< unsigned int IntegratorHPMCPolydisperse<Shape>::countOverlaps(unsigned int timestep, bool early_exit)
---
> unsigned int IntegratorHPMCMonoSwap<Shape>::countOverlaps(unsigned int timestep, bool early_exit)
940,945c1508,1510
<     unsigned int overlap_count = 0;
<     unsigned int err_count = 0;
< 
<     m_exec_conf->msg->notice(10) << "HPMCMono count overlaps: " << timestep << std::endl;
< 
<     if (!m_past_first_run)
---
>         if (m_soft_mode)
>             return 0;
>         else
947,949c1512,1513
<         m_exec_conf->msg->error() << "count_overlaps only works after a run() command" << std::endl;
<         throw std::runtime_error("Error communicating in count_overlaps");
<         }
---
>             unsigned int overlap_count = 0;
>             unsigned int err_count = 0;
951,954c1515
<     // build an up to date AABB tree
<     buildAABBTree();
<     // update the image list
<     updateImageList();
---
>             m_exec_conf->msg->notice(10) << "HPMCMono count overlaps: " << timestep << std::endl;
956,962c1517,1521
<     if (this->m_prof) this->m_prof->push(this->m_exec_conf, "HPMC count overlaps");
< 
<     // access particle data and system box
<     ArrayHandle<Scalar4> h_postype(m_pdata->getPositions(), access_location::host, access_mode::read);
<     ArrayHandle<Scalar> h_diameter(m_pdata->getDiameters(), access_location::host, access_mode::read);
<     ArrayHandle<Scalar4> h_orientation(m_pdata->getOrientationArray(), access_location::host, access_mode::read);
<     ArrayHandle<unsigned int> h_tag(m_pdata->getTags(), access_location::host, access_mode::read);
---
>             if (!m_past_first_run)
>                 {
>                 m_exec_conf->msg->error() << "count_overlaps only works after a run() command" << std::endl;
>                 throw std::runtime_error("Error communicating in count_overlaps");
>                 }
964,965c1523,1526
<     // access parameters and interaction matrix
<     ArrayHandle<unsigned int> h_overlaps(m_overlaps, access_location::host, access_mode::read);
---
>             // build an up to date AABB tree
>             buildAABBTree();
>             // update the image list
>             updateImageList();
967,976c1528
<     // Loop over all particles
<     for (unsigned int i = 0; i < m_pdata->getN(); i++)
<         {
<         // read in the current position and orientation
<         Scalar4 postype_i = h_postype.data[i];
<         Scalar4 orientation_i = h_orientation.data[i];
<         OverlapReal diameter_i = h_diameter.data[i];
<         unsigned int typ_i = __scalar_as_int(postype_i.w);
<         Shape shape_i(quat<Scalar>(orientation_i), m_params[typ_i]);
<         vec3<Scalar> pos_i = vec3<Scalar>(postype_i);
---
>             if (this->m_prof) this->m_prof->push(this->m_exec_conf, "HPMC count overlaps");
978,980c1530,1534
<         // Check particle against AABB tree for neighbors
<         //m_exec_conf->msg->notice(2) << "What is my diameter: " << diameter_i << std::endl;
<         detail::AABB aabb_i_local = shape_i.getAABB(vec3<Scalar>(0,0,0), OverlapReal(0.5)*diameter_i);
---
>             // access particle data and system box
>             ArrayHandle<Scalar4> h_postype(m_pdata->getPositions(), access_location::host, access_mode::read);
>             ArrayHandle<Scalar4> h_orientation(m_pdata->getOrientationArray(), access_location::host, access_mode::read);
>             ArrayHandle<unsigned int> h_tag(m_pdata->getTags(), access_location::host, access_mode::read);
>             ArrayHandle<Scalar> h_diameter(m_pdata->getDiameters(), access_location::host, access_mode::read);
982,987c1536,1537
<         const unsigned int n_images = m_image_list.size();
<         for (unsigned int cur_image = 0; cur_image < n_images; cur_image++)
<             {
<             vec3<Scalar> pos_i_image = pos_i + m_image_list[cur_image];
<             detail::AABB aabb = aabb_i_local;
<             aabb.translate(pos_i_image);
---
>             // access parameters and interaction matrix
>             ArrayHandle<unsigned int> h_overlaps(m_overlaps, access_location::host, access_mode::read);
989,990c1539,1540
<             // stackless search
<             for (unsigned int cur_node_idx = 0; cur_node_idx < m_aabb_tree.getNumNodes(); cur_node_idx++)
---
>             // Loop over all particles
>             for (unsigned int i = 0; i < m_pdata->getN(); i++)
992c1542,1554
<                 if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
---
>                 // read in the current position and orientation
>                 Scalar4 postype_i = h_postype.data[i];
>                 Scalar4 orientation_i = h_orientation.data[i];
>                 unsigned int typ_i = __scalar_as_int(postype_i.w);
>                 unsigned int tag_i = h_tag.data[i];
>                 Shape shape_i(quat<Scalar>(orientation_i), m_params[typ_i]);
>                 vec3<Scalar> pos_i = vec3<Scalar>(postype_i);
> 
>                 // Check particle against AABB tree for neighbors
>                 detail::AABB aabb_i_local = shape_i.getAABB(vec3<Scalar>(0,0,0),tag_i);
> 
>                 const unsigned int n_images = m_image_list.size();
>                 for (unsigned int cur_image = 0; cur_image < n_images; cur_image++)
994c1556,1561
<                     if (m_aabb_tree.isNodeLeaf(cur_node_idx))
---
>                     vec3<Scalar> pos_i_image = pos_i + m_image_list[cur_image];
>                     detail::AABB aabb = aabb_i_local;
>                     aabb.translate(pos_i_image);
> 
>                     // stackless search
>                     for (unsigned int cur_node_idx = 0; cur_node_idx < m_aabb_tree.getNumNodes(); cur_node_idx++)
996c1563
<                         for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
---
>                         if (detail::overlap(m_aabb_tree.getNodeAABB(cur_node_idx), aabb))
998,999c1565,1571
<                             // read in its position and orientation
<                             unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
---
>                             if (m_aabb_tree.isNodeLeaf(cur_node_idx))
>                                 {
>                                 for (unsigned int cur_p = 0; cur_p < m_aabb_tree.getNodeNumParticles(cur_node_idx); cur_p++)
>                                     {
>                                     // read in its position and orientation
>                                     unsigned int j = m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
>                                     unsigned int tag_j = h_tag.data[j];//m_aabb_tree.getNodeParticle(cur_node_idx, cur_p);
1001,1003c1573,1575
<                             // skip i==j in the 0 image
<                             if (cur_image == 0 && i == j)
<                                 continue;
---
>                                     // skip i==j in the 0 image
>                                     if (cur_image == 0 && i == j)
>                                         continue;
1005,1009c1577,1578
<                             Scalar4 postype_j = h_postype.data[j];
<                             Scalar4 orientation_j = h_orientation.data[j];
<                             OverlapReal diameter_j = h_diameter.data[j];
<                             // put particles in coordinate system of particle i
<                             vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
---
>                                     Scalar4 postype_j = h_postype.data[j];
>                                     Scalar4 orientation_j = h_orientation.data[j];
1011,1012c1580,1581
<                             unsigned int typ_j = __scalar_as_int(postype_j.w);
<                             Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
---
>                                     // put particles in coordinate system of particle i
>                                     vec3<Scalar> r_ij = vec3<Scalar>(postype_j) - pos_i_image;
1014,1024c1583,1605
<                             if (h_tag.data[i] <= h_tag.data[j]
<                                 && h_overlaps.data[m_overlap_idx(typ_i,typ_j)]
<                                 && check_circumsphere_overlap_plugin(r_ij, diameter_i, diameter_j)
<                                 && test_overlap_plugin(r_ij, diameter_i, diameter_j, err_count)
<                                 && test_overlap_plugin(-r_ij, diameter_j, diameter_i, err_count))
<                                 {
<                                 overlap_count++;
<                                 if (early_exit)
<                                     {
<                                     // exit early from loop over neighbor particles
<                                     break;
---
>                                     unsigned int typ_j = __scalar_as_int(postype_j.w);
>                                     Shape shape_j(quat<Scalar>(orientation_j), m_params[typ_j]);
> 
>                                     if (h_tag.data[i] <= h_tag.data[j]
>                                         && h_overlaps.data[m_overlap_idx(typ_i,typ_j)]
>                                         && check_circumsphere_overlap_plugin(r_ij, shape_i, shape_j)
>                                         && test_overlap_plugin(r_ij, shape_i, shape_j, tag_i, tag_j, err_count)
>                                         && test_overlap_plugin(-r_ij, shape_j, shape_i, tag_j, tag_i, err_count))
>                                         {
>                                         m_exec_conf->msg->notice(2) << "Overlap between: " << tag_j << "and particle " << tag_i << std::endl;
>                                         m_exec_conf->msg->notice(2) << "Diameter_j: " << shape_j.getCircumsphereDiameter(tag_j) << "and particle " << shape_i.getCircumsphereDiameter(tag_i) << std::endl;
>                                         m_exec_conf->msg->notice(2) << "Diameter_j: " << 2.0*m_params[typ_j].radii[tag_j] << "and particle " << 2.0*m_params[typ_i].radii[tag_i]<< std::endl;
>                                         m_exec_conf->msg->notice(2) << "Diameter_j: " << h_diameter.data[j] << "and particle " << h_diameter.data[i]<< std::endl;
>                                         vec3<OverlapReal> dr(r_ij);
>                                         OverlapReal rsq = dot(dr,dr);
>                                         m_exec_conf->msg->notice(2) << "r_ij squared: " << rsq << std::endl;
>                                         overlap_count++;
>                                         if (early_exit)
>                                             {
>                                             // exit early from loop over neighbor particles
>                                             break;
>                                             }
>                                         }
1027a1609,1623
>                         else
>                             {
>                             // skip ahead
>                             cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
>                             }
> 
>                         if (overlap_count && early_exit)
>                             {
>                             break;
>                             }
>                         } // end loop over AABB nodes
> 
>                     if (overlap_count && early_exit)
>                         {
>                         break;
1029,1034c1625
<                     }
<                 else
<                     {
<                     // skip ahead
<                     cur_node_idx += m_aabb_tree.getNodeSkip(cur_node_idx);
<                     }
---
>                     } // end loop over images
1040c1631
<                 } // end loop over AABB nodes
---
>                 } // end loop over particles
1042c1633,1637
<             if (overlap_count && early_exit)
---
>             if (this->m_prof) this->m_prof->pop(this->m_exec_conf);
> 
>             //CHECK THIS MUHAMMAD
>             #ifdef ENABLE_MPI
>             if (this->m_pdata->getDomainDecomposition())
1044c1639,1641
<                 break;
---
>                 MPI_Allreduce(MPI_IN_PLACE, &overlap_count, 1, MPI_UNSIGNED, MPI_SUM, m_exec_conf->getMPICommunicator());
>                 if (early_exit && overlap_count > 1)
>                     overlap_count = 1;
1046,1054c1643
<             } // end loop over images
< 
<         if (overlap_count && early_exit)
<             {
<             break;
<             }
<         } // end loop over particles
< 
<     if (this->m_prof) this->m_prof->pop(this->m_exec_conf);
---
>             #endif
1056,1061c1645
<     #ifdef ENABLE_MPI
<     if (this->m_pdata->getDomainDecomposition())
<         {
<         MPI_Allreduce(MPI_IN_PLACE, &overlap_count, 1, MPI_UNSIGNED, MPI_SUM, m_exec_conf->getMPICommunicator());
<         if (early_exit && overlap_count > 1)
<             overlap_count = 1;
---
>             return overlap_count;
1063,1065d1646
<     #endif
< 
<     return overlap_count;
1069c1650
< float IntegratorHPMCPolydisperse<Shape>::computePatchEnergy(unsigned int timestep)
---
> float IntegratorHPMCMonoSwap<Shape>::computePatchEnergy(unsigned int timestep)
1114a1696
>         //Scalar diameter_i = h_diameter.data[i];
1115a1698
>         unsigned int tag_i = h_tag.data[i];
1116a1700
>         OverlapReal diameter_i = shape_i.getCircumsphereDiameter(tag_i);
1119c1703
<         Scalar d_i = h_diameter.data[i];
---
>         //Scalar d_i = h_diameter.data[i];
1123c1707
<         Scalar r_cut = 0;//m_patch->getRCut() + 0.5*m_patch->getAdditiveCutoff(typ_i);
---
>         float r_cut_patch_ij = m_patch->getScaledRCut()*0.5*diameter_i;
1126,1127c1710,1714
<         OverlapReal R_query = std::max(OverlapReal(0.5)*d_i,
<             r_cut-getMinCoreDiameter()/(OverlapReal)2.0);
---
>         //OverlapReal R_query = std::max(shape_i.getCircumsphereDiameter()/OverlapReal(2.0),
>         //OverlapReal diameter_test = h_diameter.data[i];
>         //OverlapReal R_query = std::max(shape_i.getCircumsphereDiameter()/OverlapReal(2.0),
>         OverlapReal R_query = std::max(diameter_i/OverlapReal(2.0),
>             r_cut_patch_ij-getMinCoreDiameter()/(OverlapReal)2.0);
1148c1735
< 
---
>                             unsigned int tag_j = h_tag.data[j];
1155c1742
<                             Scalar d_j = h_diameter.data[j];
---
>                             //Scalar d_j = h_diameter.data[j];
1165c1752,1753
<                             Scalar rcut_ij = r_cut + 0.5*m_patch->getAdditiveCutoff(typ_j);
---
>                             OverlapReal diameter_j = shape_j.getCircumsphereDiameter(tag_j);
>                             Scalar rcut_ij = r_cut_patch_ij+m_patch->getScaledRCut()*0.5*diameter_j;
1172c1760
<                                        d_i,
---
>                                        diameter_i,
1176c1764
<                                        d_j,
---
>                                        diameter_j,
1210c1798
< Scalar IntegratorHPMCPolydisperse<Shape>::getMaxCoreDiameter()
---
> Scalar IntegratorHPMCMonoSwap<Shape>::getMaxCoreDiameter()
1224c1812
< OverlapReal IntegratorHPMCPolydisperse<Shape>::getMinCoreDiameter()
---
> OverlapReal IntegratorHPMCMonoSwap<Shape>::getMinCoreDiameter()
1246c1834
< void IntegratorHPMCPolydisperse<Shape>::setParam(unsigned int typ,  const param_type& param)
---
> void IntegratorHPMCMonoSwap<Shape>::setParam(unsigned int typ,  const param_type& param)
1253c1841
<         throw std::runtime_error("Error setting parameters in IntegratorHPMCPolydisperse");
---
>         throw std::runtime_error("Error setting parameters in IntegratorHPMCMonoSwap");
1267c1855
< void IntegratorHPMCPolydisperse<Shape>::setOverlapChecks(unsigned int typi, unsigned int typj, bool check_overlaps)
---
> void IntegratorHPMCMonoSwap<Shape>::setOverlapChecks(unsigned int typi, unsigned int typj, bool check_overlaps)
1274c1862
<         throw std::runtime_error("Error setting interaction matrix in IntegratorHPMCPolydisperse");
---
>         throw std::runtime_error("Error setting interaction matrix in IntegratorHPMCMonoSwap");
1281c1869
<         throw std::runtime_error("Error setting interaction matrix in IntegratorHPMCPolydisperse");
---
>         throw std::runtime_error("Error setting interaction matrix in IntegratorHPMCMonoSwap");
1293c1881
< inline const std::vector<vec3<Scalar> >& IntegratorHPMCPolydisperse<Shape>::updateImageList()
---
> inline const std::vector<vec3<Scalar> >& IntegratorHPMCMonoSwap<Shape>::updateImageList()
1352c1940
< 
---
>             //It's talking to shape diameter
1456c2044
< void IntegratorHPMCPolydisperse<Shape>::updateCellWidth()
---
> void IntegratorHPMCMonoSwap<Shape>::updateCellWidth()
1470c2058
< 
---
>     // m_nominal_width = 1.0;
1478c2066
< void IntegratorHPMCPolydisperse<Shape>::growAABBList(unsigned int N)
---
> void IntegratorHPMCMonoSwap<Shape>::growAABBList(unsigned int N)
1496c2084
< /*! Call any time an up to date AABB tree is needed. IntegratorHPMCPolydisperse internally tracks whether
---
> /*! Call any time an up to date AABB tree is needed. IntegratorHPMCMonoSwap internally tracks whether
1511c2099
< const detail::AABBTree& IntegratorHPMCPolydisperse<Shape>::buildAABBTree()
---
> const detail::AABBTree& IntegratorHPMCMonoSwap<Shape>::buildAABBTree()
1521a2110
>             ArrayHandle<unsigned int> h_tag(m_pdata->getTags(), access_location::host, access_mode::read);
1531a2121
>                     unsigned int tag_i = h_tag.data[i];
1533,1535c2123
<                     OverlapReal diameter_i = h_diameter.data[i];
<                     //m_exec_conf->msg->notice(2) << "This is my diameter " << diameter_i << std::endl;
<                     //m_exec_conf->msg->notice(2) << "This is my position at x " << h_postype.data[i].x << std::endl;
---
> 
1537c2125
<                         m_aabbs[i] = shape.getAABB(vec3<Scalar>(h_postype.data[i]),OverlapReal(0.5)*diameter_i);
---
>                         m_aabbs[i] = shape.getAABB(vec3<Scalar>(h_postype.data[i]),tag_i);
1540c2128,2129
<                         Scalar radius = std::max(0.5*diameter_i,
---
>                         //Scalar radius = std::max(0.5*diameter_i,
>                         Scalar radius = std::max(0.5*shape.getCircumsphereDiameter(tag_i),
1542a2132
>                         //m_aabbs[i] = detail::AABB(vec3<Scalar>(h_postype.data[i]), 0.5*diameter_i);
1562c2152
< void IntegratorHPMCPolydisperse<Shape>::limitMoveDistances()
---
> void IntegratorHPMCMonoSwap<Shape>::limitMoveDistances()
1595c2185
< std::vector<bool> IntegratorHPMCPolydisperse<Shape>::mapOverlaps()
---
> std::vector<bool> IntegratorHPMCMonoSwap<Shape>::mapOverlaps()
1629a2220,2221
>         //Scalar diameter_i = h_diameter.data[i];
>         unsigned int tag_i = h_tag.data[i];
1632c2224
<         OverlapReal diameter_i = h_diameter.data[i];
---
> 
1634c2226
<         detail::AABB aabb_i_local = shape_i.getAABB(vec3<Scalar>(0,0,0), OverlapReal(0.5)*diameter_i);
---
>         detail::AABB aabb_i_local = shape_i.getAABB(vec3<Scalar>(0,0,0),tag_i);
1653a2246
>                             unsigned int tag_j = h_tag.data[j];//m_aabb_tree.getNodeParticleTag(cur_node_idx, cur_p);
1662a2256
>                             //Scalar diameter_j = h_diameter.data[j];
1668d2261
<                             OverlapReal diameter_j = h_diameter.data[j];
1671,1673c2264,2272
<                                 && check_circumsphere_overlap_plugin(r_ij, diameter_i, diameter_j)
<                                 && test_overlap_plugin(r_ij, diameter_i, diameter_j, err_count)
<                                 && test_overlap_plugin(-r_ij, diameter_j, diameter_i, err_count))
---
>                                 && check_circumsphere_overlap_plugin(r_ij, shape_i, shape_j)
>                                 //&& test_overlap_plugin<Scalar,Scalar>(r_ij, diameter_i, diameter_j, err_count)
>                                 //&& test_overlap_plugin<Scalar,Scalar>(-r_ij, diameter_j, diameter_i, err_count))
>                                 && test_overlap_plugin(r_ij, shape_i, shape_j, tag_i, tag_j, err_count)
>                                 && test_overlap_plugin(-r_ij, shape_j, shape_i, tag_j, tag_i, err_count))
>                                 //&& test_overlap_plugin<Scalar,Scalar>(r_ij, shape_i.getCircumsphereDiameter(), shape_j.getCircumsphereDiameter(), err_count)
>                                 //&& test_overlap_plugin<Scalar,Scalar>(-r_ij, shape_j.getCircumsphereDiameter(), shape_i.getCircumsphereDiameter(), err_count))
>                                 //&& test_overlap_plugin<Scalar,Scalar>(r_ij, diameter_i, diameter_j, err_count)
>                                 //&& test_overlap_plugin<Scalar,Scalar>(-r_ij, diameter_j, diameter_i, err_count))
1696c2295
< pybind11::list IntegratorHPMCPolydisperse<Shape>::PyMapOverlaps()
---
> pybind11::list IntegratorHPMCMonoSwap<Shape>::PyMapOverlaps()
1698c2297
<     std::vector<bool> v = IntegratorHPMCPolydisperse<Shape>::mapOverlaps();
---
>     std::vector<bool> v = IntegratorHPMCMonoSwap<Shape>::mapOverlaps();
1709c2308
< void IntegratorHPMCPolydisperse<Shape>::connectGSDSignal(
---
> void IntegratorHPMCMonoSwap<Shape>::connectGSDSignal(
1714c2313
<     auto func = std::bind(&IntegratorHPMCPolydisperse<Shape>::slotWriteGSD, this, std::placeholders::_1, name);
---
>     auto func = std::bind(&IntegratorHPMCMonoSwap<Shape>::slotWriteGSD, this, std::placeholders::_1, name);
1720c2319
< int IntegratorHPMCPolydisperse<Shape>::slotWriteGSD( gsd_handle& handle, std::string name ) const
---
> int IntegratorHPMCMonoSwap<Shape>::slotWriteGSD( gsd_handle& handle, std::string name ) const
1722c2321
<     m_exec_conf->msg->notice(10) << "IntegratorHPMCPolydisperse writing to GSD File to name: "<< name << std::endl;
---
>     m_exec_conf->msg->notice(10) << "IntegratorHPMCMonoSwap writing to GSD File to name: "<< name << std::endl;
1747c2346
< bool IntegratorHPMCPolydisperse<Shape>::restoreStateGSD( std::shared_ptr<GSDReader> reader, std::string name)
---
> bool IntegratorHPMCMonoSwap<Shape>::restoreStateGSD( std::shared_ptr<GSDReader> reader, std::string name)
1750c2349
<     m_exec_conf->msg->notice(10) << "IntegratorHPMCPolydisperse from GSD File to name: "<< name << std::endl;
---
>     m_exec_conf->msg->notice(10) << "IntegratorHPMCMonoSwap from GSD File to name: "<< name << std::endl;
1771d2369
< /*
1773,1774c2371,2372
< bool IntegratorHPMCPolydisperse<Shape>::py_test_overlap_plugin(unsigned int type_i, unsigned int type_j,
<     pybind11::list rij, pybind11::list qi, pybind11::list qj,
---
> bool IntegratorHPMCMonoSwap<Shape>::py_test_overlap_plugin(unsigned int type_i, unsigned int type_j,
>     pybind11::list rij, pybind11::list qi, pybind11::list qj, unsigned int tag_i, unsigned int tag_j, 
1815c2413
<                 test_overlap_plugin(dr + m_image_list[cur_image], shape_i, shape_j, err))
---
>                 test_overlap_plugin(dr + m_image_list[cur_image], shape_i, shape_j, tag_i, tag_j, err))
1821c2419
<         overlap = check_circumsphere_overlap_plugin(dr, shape_i, shape_j) && test_overlap_plugin(dr, shape_i, shape_j, err);
---
>         overlap = check_circumsphere_overlap_plugin(dr, shape_i, shape_j) && test_overlap_plugin(dr, shape_i, shape_j, tag_i, tag_j, err);
1825c2423
<         m_exec_conf->msg->warning() << "test_overlap_plugin() reports an error due to finite numerical precision." << std::endl;
---
>         m_exec_conf->msg->warning() << "test_overlap_plugin<Scalar,Scalar>() reports an error due to finite numerical precision." << std::endl;
1829,1830c2427,2428
< */
< //! Export the IntegratorHPMCPolydisperse class to python
---
> 
> //! Export the IntegratorHPMCMonoSwap class to python
1832c2430
<     \tparam Shape An instantiation of IntegratorHPMCPolydisperse<Shape> will be exported
---
>     \tparam Shape An instantiation of IntegratorHPMCMonoSwap<Shape> will be exported
1834c2432
< template < class Shape > void export_IntegratorHPMCPolydisperse(pybind11::module& m, const std::string& name)
---
> template < class Shape > void export_IntegratorHPMCMonoSwap(pybind11::module& m, const std::string& name)
1836c2434
<     pybind11::class_< IntegratorHPMCPolydisperse<Shape>, std::shared_ptr< IntegratorHPMCPolydisperse<Shape> > >(m, name.c_str(), pybind11::base<IntegratorHPMCSwap>())
---
>     pybind11::class_< IntegratorHPMCMonoSwap<Shape>, std::shared_ptr< IntegratorHPMCMonoSwap<Shape> > >(m, name.c_str(), pybind11::base<IntegratorHPMCSwap>())
1838,1845c2436,2443
<           .def("setParam", &IntegratorHPMCPolydisperse<Shape>::setParam)
<           .def("setOverlapChecks", &IntegratorHPMCPolydisperse<Shape>::setOverlapChecks)
<           //.def("setExternalField", &IntegratorHPMCPolydisperse<Shape>::setExternalField)
<           .def("setPatchEnergy", &IntegratorHPMCPolydisperse<Shape>::setPatchEnergy)
<           .def("mapOverlaps", &IntegratorHPMCPolydisperse<Shape>::PyMapOverlaps)
<           .def("connectGSDSignal", &IntegratorHPMCPolydisperse<Shape>::connectGSDSignal)
<           .def("restoreStateGSD", &IntegratorHPMCPolydisperse<Shape>::restoreStateGSD)
<           //.def("py_test_overlap_plugin", &IntegratorHPMCPolydisperse<Shape>::py_test_overlap_plugin)
---
>           .def("setParam", &IntegratorHPMCMonoSwap<Shape>::setParam)
>           .def("setOverlapChecks", &IntegratorHPMCMonoSwap<Shape>::setOverlapChecks)
>           //.def("setExternalField", &IntegratorHPMCMonoSwap<Shape>::setExternalField)
>           .def("setPatchEnergy", &IntegratorHPMCMonoSwap<Shape>::setPatchEnergy)
>           .def("mapOverlaps", &IntegratorHPMCMonoSwap<Shape>::PyMapOverlaps)
>           .def("connectGSDSignal", &IntegratorHPMCMonoSwap<Shape>::connectGSDSignal)
>           .def("restoreStateGSD", &IntegratorHPMCMonoSwap<Shape>::restoreStateGSD)
>           .def("py_test_overlap_plugin", &IntegratorHPMCMonoSwap<Shape>::py_test_overlap_plugin)
1851c2449
< #endif // _INTEGRATOR_HPMC_POLYDISPERSE_H_
---
> #endif // _INTEGRATOR_HPMC_MONO_SWAP_H_
